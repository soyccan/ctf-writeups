# https://maojui.me/Writeups/AIS3/2019/RSA202/
from gmpy2 import isqrt, invert


def _is_square(x):
    from math import sqrt, round

    s = sqrt(x)
    return round(s * s) == x

    # below are a slower but more accurate method
    if x % 10 not in (0,1,4,5,6,9): return False
    if x % 4 not in (0,1): return False
    if x % 8 not in (0,1,4): return False
    if x % 3 not in (0,1): return False
    if x % 5 not in (0,1,4): return False
    if x % 16 not in (0,1,4,9): return False
    if x % 9 not in (0,1,4,7,9): return False

    if ((x % 10 == 6 and x % 100 // 10 % 2 != 1)
            or (x % 10 != 6 and x % 100 // 10 % 2 == 1)):
        return False

    # n^2 = 1 + 3 + 5 + 7 + ... + (2^n-1)
    # complexity: O(sqrt(n))
    i = 1
    while x > 0:
        x -= i
        i += 2
    return x == 0

def fermat_factorise(x):
    """factorisation with Fermat's method"""
    # x = (a+b) * (a-b) = a*a - b*b
    try:
        x = int(x)
    except:
        raise ValueError('x must be integer')

    a = isqrt(x)
    if a*a == x:
        return (int(a), int(a))

    a += 1
    b2 = a*a - x
    b = isqrt(b2)
    while not b*b == b2:
        b2 += 2 * a + 1
        b = isqrt(b2)
        a += 1
    return (int(a+b), int(a-b))

def decryptRSA(cipher, encode_key, modulus_factors):
    """decrypt an RSA-encoded ciphertext
    cipher: int / mpz
        ciphertext

    encode_key: int / mpz
        the exponential raised by plaintext when encoding

    modulus_factors: tuple (int/mpz, int/mpz)
        the two prime factors that compose the modulus
    """
    c = cipher
    e = encode_key
    p, q = modulus_factors
    phi = (p - 1) * (q - 1)
    d = invert(e, phi)
    return pow(c, d, p*q)

def solve():
    (enc1,n1) = (1866739590223797894675042930867507244459802734183817120733673558730628194296958093591260416428147300252816258812188827322730714255110909448735060349711514657617017626271999512009288, 2107308938308678911177716445910458064144687266257974485812760737810938658576811949209501139731498151019880482475847630181615827350928419914012994515153701812863112540563758947630673)
    (enc2,n2) = (163248530795584366145466296321187213658026110158596299750743781778743172552595737964301790056072986912490085246953061391284483885257738498665735626767157771907156283098113208436201643983283825273676876772787839238022891031020422513624276707856450148466389225762736796362385105469696445688681891309638174781023755119802641655564893438612083493796669067805311885650829623595933267543139261626242135235432699555110595599248445004859506377270155006701058826798660441936150822588706983021515302669371172521137844571295149622685172373494327744908196112888123678332065953631168343314059811571594464089933358509443961104580164145772222878174151684953943097830003247930257466090, 511253615204519263544098182243390136589717856442041319433025555180754843151236319051204626896440924354451122805900343959138213854792063846304100028578059057107063849531797454121744816829984347298608507894670183582383162752278318603580324753076335121183044736753607334089637983484399735525435181929280053912388968954404937630644357275435225533394978551512863984379719741181778216335681599665412578371991524213631221263036736748226521393945572475145721796400734896169295808025130609358794036061688271053581026518126801468595540707610013222172427570333613594985306843082788120035591970752197605165173130521116394862664389352265107733151148670474263880810177549111072747207)

    # n1 = r * next_prime(r)
    # since distantce between neighbouring primes is small
    # thus there exists small b such that
    r, s = fermat_factorise(n1)

    # assert ((p-1) % r)**2 + ((r**5 - 1) % p)**2 == 0
    # r | (p-1) && p | (r^5 - 1)
    # => p = r^4 + r^3 + r^2 + r + 1
    p = r**4 + r**3 + r**2 + r + 1
    q = n2 // p

    # decrypt
    plain1 = decryptRSA(enc1, e, (r,s))
    plain2 = decryptRSA(enc2, e, (p,q))

solve()
