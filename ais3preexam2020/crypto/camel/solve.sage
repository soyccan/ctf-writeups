import gmpy2
import numpy as np


# Elliptive Curve: y^2 = x^3 + a*x + b  (mod p)
# goal: find parameter (a, b, p) of the EC

# known points on the EC
known_points = [
    # (x, y)
    (-1,  759211060281786031869071242155234136314844944),
    (+1, 1057401451679095062531151979389760885573147826),
    (+2,  142926404549455192668575513920450762633800129),
    (-3,  773808304364278082418521288269860813684230337),
    (+3,  155419950529021753751813670756068418661489493),
    (-4,  564605286683346876667536567601259285744471988),
    (-5,  812270051867990261460153809983232723732262237),
    (+5,  410837747859871710141162996756729573836835781),
    (-7,  576115660671090581945855297280052151651777662),
]

# y^2 = f(x) = x^3 + a*x + b  (mod p)
pts1 = np.array([known_points[1], known_points[4], known_points[7]])
pts2 = np.array([known_points[0], known_points[3], known_points[6]])
f_x = pts1[:, 1] ** 2  # f(1), f(3), f(5)
f_x_neg = pts2[:, 1] ** 2  # f(-1), f(-3), f(-5)
b = (f_x + f_x_neg) // 2  # b = (f(x) + f(-x)) / 2
b_diff = np.diff(b)
p = math.gcd(*b_diff[:2])
print(f'{p=}')

b = b[0] % p
print(f'{b=}')

x, y = pts1[0, :]
a = (y**2 - x**3 - b) * gmpy2.invert(x, p) % p
print(f'{a=}')

# check correctness
ecc = EllipticCurve(GF(p), [a, b])
ecc.point((p-1,  759211060281786031869071242155234136314844944))
ecc.point((p+1, 1057401451679095062531151979389760885573147826))
ecc.point((p+2,  142926404549455192668575513920450762633800129))
ecc.point((p-3,  773808304364278082418521288269860813684230337))
ecc.point((p+3,  155419950529021753751813670756068418661489493))
ecc.point((p-4,  564605286683346876667536567601259285744471988))
ecc.point((p-5,  812270051867990261460153809983232723732262237))
ecc.point((p+5,  410837747859871710141162996756729573836835781))
ecc.point((p-7,  576115660671090581945855297280052151651777662))

flag = bytes.fromhex(hex(a)[2:] + hex(b)[2:] + hex(p)[2:])
print(flag)
#  AIS3{Curv3_Mak3_M3_Th1nK_Ab0Ut_CaME1_A_P}
