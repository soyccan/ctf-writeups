

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1024 = Integer(1024); _sage_const_2 = Integer(2); _sage_const_64 = Integer(64); _sage_const_1111 = Integer(1111); _sage_const_0xaa0d3a677e1be0bf = Integer(0xaa0d3a677e1be0bf); _sage_const_0 = Integer(0); _sage_const_63 = Integer(63); _sage_const_1 = Integer(1); _sage_const_1p1 = RealNumber('1.1'); _sage_const_42 = Integer(42); _sage_const_43 = Integer(43); _sage_const_90 = Integer(90)
import socket

class remote:
    def __init__(self, host, port):
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.connect((host, port))
        self.buffer = b''
    def recvuntil(self, text):
        text = self._convert_to_bytes(text)
        while text not in self.buffer:
            self.buffer += self.s.recv(_sage_const_1024 )
        index = self.buffer.find(text) + len(text)
        result, self.buffer = self.buffer[:index], self.buffer[index:]
        return result
    def recvline(self):
        return self.recvuntil(b'\n')
    def recvlines(self, n):
        lines = []
        for _ in range(n):
            lines.append(self.recvline())
        return lines
    def _convert_to_bytes(self, text):
        if type(text) is not bytes:
            text = str(text)
        if type(text) is str:
            text = text.encode()
        return text
    def send(self, text):
        text = self._convert_to_bytes(text)
        self.s.sendall(text)
    def sendline(self, text):
        text = self._convert_to_bytes(text)
        self.send(text + b'\n')
    def sendafter(self, prefix, text):
        self.recvuntil(prefix)
        self.send(text)
    def sendlineafter(self, prefix, text):
        self.recvuntil(prefix)
        self.sendline(text)


F = GF(_sage_const_2 **_sage_const_64 , names=('x',)); (x,) = F._first_ngens(1)

r = remote('localhost', _sage_const_1111 )

def matrix_repr_step():
    """ matrix representation of step() """
    poly = _sage_const_0xaa0d3a677e1be0bf 
    poly = vector(F.fetch_int(poly))
    step = []
    for i in range(_sage_const_64 ):
        row = [ poly[i] ] + [_sage_const_0 ] * _sage_const_63 
        if i < _sage_const_63 :
            row[i+_sage_const_1 ] = _sage_const_1 
        step.append(row)
    step = Matrix(GF(_sage_const_2 ), step)
    return step

def get_result():
    """ guess 64 times and get result """
    result = []
    money = _sage_const_1p1 
    for _ in range(_sage_const_64 ):
        r.sendlineafter('> ', '0')
        new_money = float(r.recvline())
        if new_money > money:
            result.append(_sage_const_0 )
        else:
            result.append(_sage_const_1 )
        money = new_money
    return result

def test_get_result():
    """ local version of get_result(), for testing """
    result = []
    for _ in range(_sage_const_64 ):
        result.append(random())
    return result

def recover_init_state():
    step = matrix_repr_step()
    base = step**_sage_const_42 
    mul = step**_sage_const_43 
    lsb = vector(F([_sage_const_1 ] + [_sage_const_0 ] * _sage_const_63 )).row()
    mat = []
    guess = get_result()
#      guess = test_get_result()
    for _ in guess:
        mat.append((lsb * base).list())
        base *= mul

    guess = vector(F(guess))
    mat = Matrix(GF(_sage_const_2 ), mat)
    init_state = mat.solve_right(guess) # solve: mat*x = guess

    return F(init_state).integer_representation()

def test_step():
    global state
    print('state0=',state)

    S = matrix_repr_step()
    ss = vector(F.fetch_int(state)).column()
    state1 = F((S * ss).column(_sage_const_0 )).integer_representation()
    print('state1=', state1)

    step()
    print('state1=',state)
    assert state == state1

    print()


# from task.py:
def step():
    global state
    poly = _sage_const_0xaa0d3a677e1be0bf 
    out = state & _sage_const_1 
    state >>= _sage_const_1 
    if out:
        state ^= poly
    return out

def random():
    for _ in range(_sage_const_42 ):
        step()
    return step()
# end task.py


state = recover_init_state()

for _ in range(_sage_const_64 ):
    random()
for _ in range(_sage_const_90 ):
    a = random()
    r.sendlineafter('> ', str(a))
    print(r.recvline())


